<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>semaine6</title>
<!-- 2016-04-08 ven. 09:34 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="noe" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">semaine6</h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Création des données de test</h2>
<div class="outline-text-2" id="text-1">
<p>
Nous avons décidé de nous restreidre au cas le plus simple, c'est à dire que l'image issue d'une recompression a un facteur de qualité strictement inférieur à celui de son parent.
Les facteurs de qualité sont tous des multiples de 5, on ne descendra pas en dessous de Q<sub>f</sub> = 30, l'image originale peut prendre toutes les valeurs &ge; 30.
</p>

<p>
Ces contraintes réduisent grandement l'espace des combinaisons possibles, et on peut se retrouver dans le cas suivant : 
</p>

<div class="figure">
<p><img src="./sameQ.png" alt="sameQ.png" width="1000px" align="left" float="left" />
</p>
</div>

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<p>
où les noeuds de la même couleur représentent des images identiques et le nombre à droite du nom représente le facteur de qualité.
</p>

<p>
Si on considère que la compression JPEG est une fonction au sens mathématique du terme, c'est à dire que la même entrée donne toujours la même sortie, les images ayant les noeuds de la même couleurs sont identiques au pixel près, et donc interchangeables.
Dans ce cas il n'est plus vraiment intéressant, ni pertinent de tenter de reconstruire l'arbre. Savoir qui est le parent de qui alors inutile puisque les images peuvent être interchangées.
</p>

<p>
Dans ce cas nous n'allons pas tenter de reconstruire l'arbre, il sera de toute façon probablement faux si les images sont identifiées par leurs noms, nous allons plutôt tenter de reconstituer l'historique des compressions des images.
Cela donnera un arbre simplifié où chaque image n'apparaitra qu'une seule fois, comme l'arbre suivant qui est la version simplifiée de l'arbre précédent : 
</p>


<div class="figure">
<p><img src="./simplified.png" alt="simplified.png" width="800px" align="left" float="left" />
</p>
</div>

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<p>
Pour évaluer ce résultat, il semble plus judicieux de regarder si l'historique de compression est juste plutôt que de regarder si les parents, identifiés par leurs noms, sont corrects.
</p>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Calcul de parenté</h2>
<div class="outline-text-2" id="text-2">
<p>
Dans un premier temps, nous n'utilisons pas de données issues de compressions JPEG, nous utilisons des vecteurs générés aléatoirement.
</p>

<ul class="org-ul">
<li>création du vecteur
<ul class="org-ul">
<li>1000 valeurs entre 0 et 500
</li>
</ul>
</li>
<li>création de l'historique des quantifications
<ul class="org-ul">
<li>Quand cela doit être le parent
<ul class="org-ul">
<li>h1: 2-5 Q toujours décroissants
</li>
<li>h2: 1-4 valeurs de h1 (h2 est le parent de h1 - h2 est un sous-ensemble de h1)
</li>
</ul>
</li>
<li>Quand cela ne doit pas être le parent
<ul class="org-ul">
<li>h1: 2-5 Q toujours décroissants
</li>
<li>h2: 2-5 Q toujours décroissants
</li>
</ul>
</li>
</ul>
</li>
<li>quantification et quantification inverse du vecteur avec h1 et h2
</li>
</ul>

<p>
Le test de négation de parenté se fait de la manière suivante : 
</p>
<ul class="org-ul">
<li>Soient deux distributions D<sub>1</sub> et D<sub>2</sub>
</li>
<li>On quantifie D<sub>1</sub> et D<sub>2</sub> avec min(Q<sub>1</sub>, Q<sub>2</sub>)
</li>
<li>On quantifie ensuite D<sub>2</sub> avec Q<sub>f</sub> = 100
</li>
<li>On regarde ensuite si l'un est un sous ensemble de l'autre
</li>
</ul>

<p>
C'est une méthode naive, mais cela donne de bons résultats avec des vecteurs générés aléatoirement, 75% de prédictions correctes avec 5% de faux positifs et 15% de faux négatifs. 
</p>

<p>
Cette méthode part du principe que si deux distributions ont été quantifiées avec des Q différents, les valeurs manquantes ne seront pas les mêmes. Le marqueur prouvant qu'une distribution n'est pas le parent d'une autre est la présence de valeurs dans une et pas dans l'autre. Cette méthode marche bien sur des données aléatoires, mais va-t'elle fonctionner sur des données issues de compressions JPEG ? Les coefficients DCT ne sont pas exactement des multiples de Q à cause des différents changement de domaine qu'ils ont subis, ils se concentrent autour des multiples de Q, il faudra donc surement les traiter au préalable.
</p>

<p>
Même si cette méthode fonctionne très bien avec des données aléatoires, elle donne de très mauvais résultats avec des données réelles. Cela vient probablement du fait que les coefficients DCT ne sont pas exactement des multiples de Q<sub>f</sub> à cause des différents changement de domaines et troncages et arrondis que cela comporte. Les valeurs ne sont donc pas exactement sur les multiples, mais réparties autour, ce qui se répèrcute à chaque recompression et décale complètement les valeurs.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: noe</p>
<p class="date">Created: 2016-04-08 ven. 09:34</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
